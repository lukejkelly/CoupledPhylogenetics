\documentclass[11pt,a4paper]{article}

% Setting up.
\usepackage[margin=1in]{geometry}
\usepackage{amsthm,amsmath,amsfonts,amssymb,mathtools}
\usepackage[authoryear,round]{natbib}
\usepackage{parskip}

\usepackage[sfdefault]{FiraSans}
\usepackage{eucal}
\usepackage{palatino}
\usepackage[T1]{fontenc}

\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{color,colortbl}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{subcaption}

\usepackage{algorithm,algpseudocode}
\algrenewcommand\algorithmicindent{1em}
\algnewcommand\algorithmicinput{\textbf{Input:}}
\algnewcommand\algorithmicoutput{\textbf{Output:}}
\algnewcommand\Input{\item[\algorithmicinput]}%
\algnewcommand\Output{\item[\algorithmicoutput]}%

\usepackage{graphicx}
\graphicspath{{./figs/}}

\usepackage[colorlinks,citecolor=RoyalBlue,urlcolor=RoyalBlue,
            linkcolor=RoyalBlue,bookmarks=false]{hyperref}

\usepackage[framed]{matlab-prettifier}
\lstMakeShortInline"
\lstset{style=Matlab-editor,
        basicstyle=\mlttfamily,
        % escapechar=",
        mlshowsectionrules=true}

% Some macros
\usepackage{luke-macros}

\definecolor{myblue}{rgb}{0.25, 0.75, 1.00}
\definecolor{mygreen}{rgb}{0.75, 1.00, 0.00}
\definecolor{myred}{rgb}{1.00, 0.50, 0.50}
\definecolor{myorange}{rgb}{1.00 0.75 0.25}

\title{\vspace{-2.5cm} Coupled MCMC for phylogenetic trees}
\author{Luke Kelly and Robin Ryder}
\date{January 2020}

\begin{document}

\maketitle
\tableofcontents

%%
\section{Overview}

Many modern phylogenetic methods specify a generative model and take a Bayesian approach to inference. We can sample from the posterior distribution on phylogenies and model parameters via Markov chain Monte Carlo (MCMC) \citep{bouckaert19}, and more recently via piecewise-deterministic Markov processes \citep{zhang19,koskela20}, sequential Monte Carlo \citep{wang19} or variational approximations \citep{zhang19vb}.

In any case, we lack methods to properly quantify convergence or mixing of Markov schemes on the space of trees, so it is difficult to separate modelling and fitting errors. Constructing a chain which explores the posterior in a reasonable amount of time is a difficult problem and an active area of research \citep{whidden19}. As data sets increase in size, practitioners resort to running ever longer chains from different initial states \citep{whidden15}. Howevever, we still lack tools to remove potential bias in estimators with respect to the posterior distribution, and the tools to evaluate the convergence of the underlying Markov chains are ad hoc.

%%
\section{Phylogenetics}

We're interested in sampling from a phylogenetic model of species diversification. We have a generative model
\begin{itemize}
    \item A branching process on sets of traits represents evolving species
    \item At a speciation event, the parent gives rise to identical offspring
    \item Species diversify over time according to a stochastic process
    \item We record the outcome of this process, the observed taxa.
\end{itemize}
In a phylogenetic tree, the leaves and represent the observed taxa and the internal nodes are unobserved speciation events, while branches depict ancestral relationships and their lengths represent elapsed evolutionary time. \figref{fig:phylogenetic-tree} displays an example of this generative model.

\begin{figure}[htb]
	\centering
	\includegraphics[width=\textwidth]{SetsTree}
    \caption{A phylogenetic tree depicting a branching process on sets of traits; the sets in turn diversify according to an evolutionary process. The unobserved \textcolor{myblue}{internal nodes} represent the most recent common ancestor of the observed \textcolor{mygreen}{leaves}.}
    \label{fig:phylogenetic-tree}
\end{figure}

Having observed the terminal outcome of this process --- the species recorded at the leaves of the tree --- we want to infer both the phylogenetic tree ($ g $, both the ancestral relationships and the node times) and other parameters of interest (rate $ \mu $ for now); any other parameters are integrated out of our inference or ignored for now.

A tree with $ L $ leaves has $ 2 L $ nodes: $ L - 1 $ internal nodes of which the \emph{root} is the most recent common ancestor of all the leaves. In addition, the \emph{Adam} node is the parent of the root. Let $ A $ denote the indices of the internal nodes and $ R $ the root. In \figref{fig:phylogenetic-tree}, $ R = 1 $, $ A = 2 $ and the Adam node is not shown.

For each node $ i \in g $, we denote
\begin{itemize}
    \item its time $ t_i \in \Rnn $
    \item its parent $ \pa(i) $.
\end{itemize}
Depending on the context, we may refer to the edge $ \edge{\pa(i)}{i} $ into $ i $ as \emph{branch $ i $}. In addition, $ i $'s neighbours are
\begin{itemize}
    \item its grandparent $ \pa^2(i) = \pa(\pa(i)) $
    \item its offspring $ \off(i) = \{j : \pa(j) = i\} $
    \item its sibling $ \sib(i) = \{j \neq i : \pa(j) = \pa(i)\} $.
\end{itemize}
In \figref{fig:phylogenetic-tree}, $ \pa(3) = 1 $, $ \sib(3) = 2 $ and $ \off(3) = \emptyset $.


%%
\section{MCMC on phylogenetic trees}

Let $ X = (g, \mu) $. We wish to construct a Markov chain $ X_0, X_1, X_2, \dotsc $ targeting a posterior distribution $ \pi $ using MCMC. This is challenging for a number of reasons, including
\begin{itemize}
    \item $ X $ is a mixture of categorical and continuous parameters with some additional constraints, such as
    \begin{itemize}
        \item We cannot have $ t_i \geq t_{\pa(i)}) $
        \item A \emph{clade} constraint may restrict a group of taxa to form a subtree.
    \end{itemize}
    \item It is difficult to compute neighbourhoods of states or construct transition kernels which only propose valid moves.
    \item Phylogenetic posterior distributions are highly multimodal \citep{whidden15,whidden19}
\end{itemize}
Consequently, we typically only attempt to update a small number of components of $ X $ at each iteration of the Markov chain. To generate a candidate state for the Markov chain, we
\begin{enumerate}
    \item Select a move type $ M $ from a family of distributions (see \tabref{tab:moves-uncoupled})
    \item Form the proposed state $ X' $ as a simple modification of the current state, $ X' \leftarrow f_M(X, U) $, where $ U $ is a random number stream.
\end{enumerate}
In short, the move types in \tabref{tab:moves-uncoupled} update either the \textcolor{RoyalBlue}{tree structure and (possibly one node time)}, the \textcolor{YellowOrange}{temporal components of the tree} or the \textcolor{OrangeRed}{scalar parameters of the diversification process}.

\begin{table}[htb]
    \centering
    \caption{MCMC move types act on the \textcolor{RoyalBlue}{tree structure}, \textcolor{YellowOrange}{tree times} or the \textcolor{OrangeRed}{parameters of the diversification process}.}
    \label{tab:moves-uncoupled}
    \begin{tabular}{cll}
        \toprule
        M & Type & What changes \\ \midrule
        \rowcolor{RoyalBlue!50}
        1 & Exchange edges (narrow) & Swap parents of neighbouring node pair \\
        \rowcolor{RoyalBlue!50}
        2 & Exchange edges (wide) & Swap parents of randomly chosen node pair \\
        \rowcolor{RoyalBlue!50}
        3 & Subtree prune-and-regraft (narrow) & Neighbouring subtree parents and times \\
        \rowcolor{RoyalBlue!50}
        4 & Subtree prune-and-regraft (wide) & Randomly chosen subtree parents and times \\
        \rowcolor{YellowOrange!50}
        5 & Random walk on node time & One internal node time \\
        \rowcolor{YellowOrange!50}
        6 & Rescale tree & All internal node times by a common factor \\
        \rowcolor{YellowOrange!50}
        7 & Rescale subtree & All subtree node times by a common factor \\
        \rowcolor{OrangeRed!50}
        8 & Vary $ \mu $ & Rescale trait death rate \\
        \bottomrule
    \end{tabular}
\end{table}

We now describe how to sample a proposed move. In each case, the output is a candidate state $ X' $ generated from the current state $ X $.

%%
\subsection{Structural moves}

Narrow moves act on a node $ i $ and its uncle $ j $, while wide moves operate on nodes $ i $ and $ j $ chosen randomly across the tree. Given $ i $, $ j $ and any new node times, the update is the same in both cases.

Let $ L $ denote the set of leaves and $ A $ the set of internal nodes including the root $ R $.

%%
\subsubsection{Edge exchange}

% \algoref{alg:edge-exchange} describes the edge exchange moves in pseudocode and gives a flavour of the type of constraints on proposals.
%
% \begin{algorithm}[htb]
%     \caption{Edge exchange}
%     \label{alg:edge-exchange}
%     \begin{algorithmic}
%         \If {$ \text{move type} = \text{narrow} $}
%             \State $ p \sim \Unif{A \setminus R} $
%             \State $ i \sim \Unif{\off[p]} $
%             \State $ j \leftarrow \sib[\pa(i)] $
%             \If {$ t_j \geq t_{\pa(i)} $ [or any clades violated]}
%                 \State \Return FAIL
%             \EndIf
%         \Else
%             \State $ i \sim \Unif{A \setminus (R \cup \{i : \pa(i) = R, t_{\sib(i)} < t_i}\})} $
%             \State $ j \sim \Unif{L \cup A} $
%             \If {$ \lnot(i \neq j, \pa(i) \neq \pa(j), i \neq \pa(j), j \neq \pa(i), t_j < t_{\pa(i)}, t_i < t_{\pa(j)}, [\text{clades}\dots]) $}
%                 \State \Return FAIL
%             \EndIf
%         \EndIf
%         \State $ [\pa(i), \pa(j)] \leftarrow [\pa(j), \pa(i)] $
%     \end{algorithmic}
% \end{algorithm}

For a narrow move, we
\begin{enumerate}
    \item Sample $ i \sim \Unif{i' : \pa(i') \in A \setminus R} $
    \item Set $ j \leftarrow \sib[\pa(i)] $.
    \item "if" $ t_j \geq t_{\pa(i)} $ [or any clades violated] then the move fails and the function exits.
\end{enumerate}
For a wide move, we
\begin{enumerate}
    \item Sample node $ i \sim \Unif{A \setminus (R \cup \{i : \pa(i) = R, t_{\sib(i)} < t_i\})} $
    \item Sample node $ j \sim \Unif{L \cup A} $
    \item "if" $ \lnot(i \neq j, \pa(i) \neq \pa(j), i \neq \pa(j), j \neq \pa(i), t_j < t_{\pa(i)}, t_i < t_{\pa(j)}, [\text{clades}\dots]) $, then the move fails and the function  exits.
\end{enumerate}
To complete the move, switch the parents: $ [\pa(i), \pa(j)] \leftarrow [\pa(j), \pa(i)] $.

As nodes are chosen uniformly at random, the ratio of proposal distributions is 1 when the proposal succeeds.

In \figref{fig:phylogenetic-tree}, for a narrow move we could have $ i = 4 \text{ or } 5 $ and swap the role of nodes $ 1 \text{ and } 2 $; our construction would not allow $ i = 1 $ here as its parent is the root so does not have a sibling.

%%
\subsubsection{Subtree prune-and-regraft}

For a SPR move on the subtree beneath node $ i $, we detach its parent from the tree then reattach it along the destination branch $ \edge{k}{j} $.
% \algoref{alg:spr} describes these types of moves in pseudocode.

% \begin{algorithm}[t]
%     \begin{algorithmic}
%         \caption{Subtree prune-and-regraft moves}
%         \label{alg:spr}
%         \State $ i \sim \Unif{L \cup A \setminus R} $
%         \If {$ \text{move type} = \text{narrow} $}
%             \State $ k = \pa^2(i) $ and $ j = \sib(\pa(i)) $
%             \If {$ \pa(i) = R $}
%                 \State \Return FAIL \Comment{$ \sib(\pa(i)) = \emptyset $}
%             \Else
%                 \State $ k = \pa^2(i) $ and $ j = \sib(\pa(i)) $
%             \EndIf
%             \State $ t_{\pa(i)}' \sim \Unif{t_i \vee t_j, t_k} $ \Comment{Uniform on valid range of destination edge}
%         \Else
%             \State $ r \leftarrow L \cup A $ \Comment{set of possible destination edges [ignoring clade constraints]}
%             \If {$ \abs{r} \leq 4 $}
%                 \State \Return FAIL
%             \EndIf
%             \State $ j \sim \Unif{j' \in r : t_{\pa(j')} > t_i, i \neq j', i \neq \pa(j)} $ and $ k \leftarrow \pa(j) $
%             \If {$ \pa(i) = k \text{ or } \pa(i) = j $}
%                 \State \Return FAIL
%             \EndIf
%             \If {$ j = R $}
%                 \State $ t_{\pa(i)}' = t_j + \Exp{\theta} $ \Comment{Sample exponential time above root}
%             \Else
%                 \State Same as narrow move but with a different ratio of proposal distributions if $ k = R $
%             \EndIf
%         \EndIf
%     \end{algorithmic}
% \end{algorithm}

For a narrow move
\begin{enumerate}
    \item Sample subtree
    \begin{itemize}
        \item Sample $ i \sim \Unif{A} $
    \end{itemize}
    \item Get destination branch
    \begin{itemize}
        \item "if" $ \pa(i) = R $, the move fails (as $ \sib(\pa(i)) = \emptyset $) and the function exits
        \item "else" $ k = \pa^2(i) $ and $ j = \sib(\pa(i)) $
    \end{itemize}
    \item Sample new node time
    \begin{itemize}
        \item $ t_{\pa(i)}' \sim \Unif{t_i \vee t_j, t_k} $.
    \end{itemize}
\end{enumerate}
For a wide move, we also need to account for clade constraints.
\begin{enumerate}
    \item Sample subtree
    \begin{itemize}
        \item Sample $ i \sim \Unif{A} $
    \end{itemize}
    \item Get a set $ r $ of possible destination edges indexed by the offspring node
        \begin{itemize}
            \item "if" [ignoring clade constraints]
            \item "else" $ r = V $
        \end{itemize}
    \item Select a destination edge
        \begin{itemize}
            \item "if" $ \abs{r} \leq 4 $, then the move fails and the function exits
            \item "else" $ j \sim \Unif{j' \in r : t_{\pa(j')} > t_i, i \neq j', i \neq \pa(j')} $ (drawn from the set of edges whose parent is older than $ i $ and don't connect to it) and $ k \leftarrow \pa(j) $
        \end{itemize}
    \item "if" $ \pa(i) = k $ or $ \pa(i) = j $, then the function fails and exits
    \item Propose a new time for $ \pa(i) $
    \begin{itemize}
        \item "if" $ j = R $, then $ t_{\pa(i)}' \leftarrow t_j + \Exp{\theta} $
        \item "else" same as narrow move but with a different ratio of proposal distributions when $ k = R $
    \end{itemize}
\end{enumerate}
To complete the move we update the tree structure and node times: $ [\pa(j), \pa^2(i)] \leftarrow [\pa(i), k] $.

\figref{fig:spr-narrow} illustrates a narrow SPR move.
\begin{figure}[htb]
	\centering
	\includegraphics[width=\textwidth]{catSPRx2}
    \caption{Example of a narrow SPR move.}
    \label{fig:spr-narrow}
\end{figure}


%%
\subsection{Temporal moves}

We denote $ \Exp{\theta; t} $ an $ \Exp{\theta} $ random variable restricted to be greater than $ t $.

%%
\subsubsection{Random walk on node time}


\begin{enumerate}
    \item Sample the node to move
    \begin{itemize}
        \item $ i \sim \Unif{A} $
        \item $ j \leftarrow \argmax_{j' \in \off(i)} t_{j'} $
    \end{itemize}
    \item The new node time is either uniform on the interval between its parent and eldest child, or if we're shifting the root then its uniform on an interval around the current value.
    \begin{itemize}
        \item "if" $ i = R $,
        \[
            t_i' \sim \UNIF{\frac{t_i + t_j}{2}, 2(t_i - t_j)}
                = t_i + \UNIF{-\frac{t_i - t_j}{2}, t_i - t_j}
        \]
        \item "else" $ t_i' \sim \Unif{t_j, t_{\pa(i)}} $.
    \end{itemize}
\end{enumerate}

%%
\subsubsection{Rescale tree or subtree}

In both cases, we attempt to scale nodes by a common factor $ \nu $.

For the entire tree, we generate the candidate state
\begin{enumerate}
    \item Sample $ \nu \sim \Unif{\delta^{-1}, \delta} $ (with $ \delta = 2 $)
    \item Set $ j \leftarrow \argmin_{j' \in g} t_j $
    \item For each node $ i \in A $,
    \[
        t_i' \leftarrow t_j + \nu (t_i - t_j).
    \]
    \item The move fails if any leaf time is greater than its parent
    \item Set $ \mu' \leftarrow \mu / \nu $ so that the expected number of trait deaths remains constant.
\end{enumerate}
The subtree move is similar.

%%
\subsection{Scalar moves}

We apply a simple scaling $ \mu' = \mu \times \Unif{\delta^{-1}, \delta} $.

%%
\section{Coupled MCMC proposals}

We would now like to couple at a lag $ l $ two Markov chains $ (X_t)_t $ and $ (Y_t)_t $ targeting $ \pi $: both chains are initialised by sampling from the prior $ \pi_0 $, the $ X $ chain is advanced by $ l $ iterations from a marginal MCMC targeting $ \pi $, and then we sample $ (X_t, Y_{t - l})_t $ by coupling the various proposal distributions and a separate coupling of the accept/reject step.

\tabref{tab:moves-coupled} repeats the moves in \tabref{tab:moves-uncoupled} coloured by whether we are coupling them using common random numbers of maximal couplings.

\begin{table}[htb]
    \centering
    \caption{Moves coupled by \colorbox{myblue!50}{common random numbers} or \colorbox{mygreen!50}{maximally}.}
    \label{tab:moves-coupled}
    \begin{tabular}{rl}
        \toprule
        M & Type \\ \midrule
        \rowcolor{myblue!50}
        1 & Exchange edges (narrow)\\
        \rowcolor{myblue!50}
        2 & Exchange edges (wide) \\
        \rowcolor{mygreen!50}
        3 & Subtree prune-and-regraft (narrow)\\
        \rowcolor{mygreen!50}
        4 & Subtree prune-and-regraft (wide) \\
        \rowcolor{mygreen!50}
        5 & Random walk on node time \\
        \rowcolor{myblue!50}
        6 & Rescale tree \\
        \rowcolor{myblue!50}
        7 & Rescale subtree \\
        \rowcolor{mygreen!50}
        8 & Vary $ \mu $ \\
        \bottomrule
    \end{tabular}
\end{table}

In order to couple moves on trees, we do "housekeeping" on the states before every move so that common parts of trees have identical labels. Thus when $ X $ and $ Y $ have a subtree in common, if a proposal modifies the subtree in $ X $ then it will always attempt the same modification in $ Y $.

For each coupled move \tabref{tab:moves-coupled}, we return the same (log-)proposal ratios as in the corresponding marginal moves.

%%
\subsection{Common random number couplings}

The random number generator is initialised to the same state before each call to the marginal move. We then re-seed the RNG afterwards in case uncoupled chains made a different number of calls to the RNG; for example, when a move fails in one chain.

%%
\subsubsection{Edge exchange}

These moves sample from discrete uniform distributions so our common random number coupling should be identical to a maximal coupling of the marginal move.

%%
\subsubsection{Rescaling a tree or subtree}

These moves use a single random variable to scale multiple parameters so cannot be maximally coupled as the supports do not overlap (except in special cases).

%%
\subsection{Maximal couplings}

At each step of the move, we sample from a coupling of the distributions described above.

%%
\subsubsection{Rescaling node times}

Through housekeeping, the trees in $ X $ and $ X $ have the same root index ($ R^{(X)} = R^{(Y)} $) so if we attempt to change the time of the root in $ X $ then we'll do the same in $ Y $. We just need to couple the sampling of new node times from the appropriate Uniform distributions.

%%
\subsubsection{SPR moves}

When coupling SPR moves, we need to account for all combinations of failures, move types and destination edge locations.
\begin{enumerate}
    \item Select the destination edge. Either or both chains can fail at this stage.
    \begin{itemize}
        \item "if" move type is narrow, destination $ \edge{k^{(X)}}{j^{(X)}} $ may not be the same as $ \edge{k^{(Y)}}{j^{(Y)}} $
        \item "else" move type is wide, then [ignoring clades] we sample destination edge $ \edge{\pa(j)}{j)} $ uniformly from the same set $ r $ of possible destinations
        \begin{itemize}
            \item We couple selecting $ j^{(X)} $ and $ j^{(Y)} $ through a similar process to common random numbers
            \item We shuffle $ r $ and each chain goes through it in the same order and selects the first valid destination in the list
            \item Each chain moves through the candidate destination set in the same order, so if an edge is valid in both and is considered by both then both chains will select it
            \item In practice, an edge may be invalid for one state as time ranges do not overlap so the move can fail in one state and succeed in another, or select different candidate edges.
        \end{itemize}
    \end{itemize}
    \item Propose node times (we discuss the actual sampling mechanisms below)
    \begin{itemize}
        \item "if" neither chain has failed, sample from a coupling
        \begin{itemize}
            \item "if" $ j^{X} = j^{Y} = R $, then
            \[
                (t_{\pa(i)}^{X}, t_{\pa(i)}^{Y}) \sim \Gamma\big(\Exp{\theta; t_j^{(X)}}, \Exp{\theta; t_j^{Y}}\big),
            \]
            both new ages Exponential above respective current root.
            \item "elseif" $ j^{(x)} = R $, then draw new age in x from Shifted Exponential and y from Uniform,
            \[
                (t_{\pa(i)}^{(x)}, t_{\pa(i)}^{(y)}) \sim \Gamma\big(\Exp{\theta; t_j^{(x)}}, \Unif{t_i^{(y)} \vee t_j^{(y)}, t_k^{(y)}}\big)
            \]
            \item "elseif" $ j^{(y)} = R $, then draw new age in x from Uniform and y from Shifted Exponential
            \item "else", both new ages uniform,
            \[
                (t_{\pa(i)}^{(x)}, t_{\pa(i)}^{(y)}) \sim \Gamma\big(\Unif{t_i^{(x)} \vee t_j^{(x)}, t_k^{(x)}}, \Unif{t_i^{(y)} \vee t_j^{(y)}, t_k^{(y)}}\big),
            \]
            ratio of proposals depends on whether $ \pa(i) $ is the root or not.
        \end{itemize}
        \item "else" one chain has failed so draw $ t_{\pa(i)}' $ in the other from the marginal sampler
    \end{itemize}
\end{enumerate}

%%
\subsubsection{Moves on scalar parameters}

These are covered in the section below.

%%
\section{Sampling couplings}

We use two approaches to sample $ X \sim p $ and $ Y \sim q $ from a maximal coupling.
\begin{itemize}
    \item Sample from overlap or sample independently
    \begin{enumerate}
        \item With probability $ [p \wedge q] = \int (p \wedge q)(\mathrm{d} x) $,
        \[
            X \leftarrow Y \sim \frac{p \wedge q}{[p \wedge q]}
        \]
        \item Otherwise
        \[
            X \sim \frac{p - p \wedge q}{1 - [p \wedge q]}
            \quad \text{and} \quad
            Y \sim \frac{q - p \wedge q}{1 - [p \wedge q]}.
        \]
    \end{enumerate}
    \item Sample $ X $ and do rejection sampling for $ Y $ \citep[Algorithm 2]{jacob20}.
\end{itemize}

%%
\subsection{Two Shifted Exponential distributions}

We have $ p = \Exp{\theta; a_p} $ and $ q = \Exp{\theta; a_q} $.

With probability $ [p \wedge q] = \exp(-\theta \abs{a_p - a_q}) $, we couple and
\[
X \leftarrow Y \sim \Exp{\theta; a_p \vee a_q}.
\]
Otherwise, sample independently. Let $ \Exp{\theta; c, d} $ denote an Exp($ \theta $) distribution truncated to $ [c, d) $. Now, if $ a_p < a_q $, then
\begin{alignat*}{3}
    X &\sim \Exp{\theta; a_p, a_q}
        &=& a_p - \theta^{-1} \log[1 - U_x (1 - e^{-\theta (a_q - a_p)})], \\
    Y &\sim \Exp{\theta; a_q}
        &=& a_q - \theta^{-1} \log(U_y),
\end{alignat*}
where $ U_x \text{ and } U_y \sim \Unif{0, 1} $. If $ a_q < a_p $ then we change the sampling distributions appropriately.

%%
\subsection{Uniform and Shifted Exponential}

Suppose $ X \sim p = \Unif{a, b} $ and $ Y \sim q = \Exp{\theta; c} $. In this setting we use a "while" loop to sample from the coupling using the recipe in \citet{jacob20}.

%%
\subsection{Uniform scaling moves}

It is straightforward to compute $ [p \wedge q] $ and the other terms in order to sample from the overlap or independently.

%%
\subsection{Uniform and Uniform}

Same as the Uniform and Shifted Exponential so we use the same "while" loop to draw $ Y $ but with appropriate sampling and density functions.

%%
\bibliographystyle{plainnat}%
\bibliography{kernel}%

\end{document}
